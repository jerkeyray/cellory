// Cellory — Prisma schema (Neon Postgres)
// Data model per PRD §5

generator client {
  provider = "prisma-client-js"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------------------------------------------------------------------------
// Enums
// ---------------------------------------------------------------------------

enum TranscriptStatus {
  processing
  ready
  error

  @@map("transcript_status")
}

enum CallOutcome {
  success
  failure

  @@map("call_outcome")
}

enum CallStatus {
  pending
  extracting
  aggregating
  complete
  error

  @@map("call_status")
}

// ---------------------------------------------------------------------------
// Models
// ---------------------------------------------------------------------------

model Transcript {
  id                String           @id @default(uuid())
  userId            String           @map("user_id")
  filename          String
  content           String           @db.Text
  durationSeconds   Int?
  wordTimestamps    Json?
  language          String?
  qualityScore      Float?           @map("quality_score")
  wordCount         Int?             @map("word_count")
  status            TranscriptStatus @default(processing)
  createdAt         DateTime         @default(now())

  // Audio metadata
  audioFormat       String?          @map("audio_format")
  audioSampleRate   Int?             @map("audio_sample_rate")
  audioChannels     Int?             @map("audio_channels")
  audioBitrate      Int?             @map("audio_bitrate")

  // Whisper segment quality data
  whisperSegments   Json?            @map("whisper_segments")
  avgConfidence     Float?           @map("avg_confidence")
  speechRatio       Float?           @map("speech_ratio")
  languageConfidence Float?          @map("language_confidence")

  // Structured diarization
  diarizationSegments Json?          @map("diarization_segments")
  speakerCount      Int?             @map("speaker_count")

  // NLU
  nluResults        Json?            @map("nlu_results")

  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  calls             Call[]

  @@index([userId])
  @@map("transcripts")
}

model Call {
  id                 String      @id @default(uuid())
  userId            String      @map("user_id")
  transcriptId       String      @map("transcript_id")
  outcome           CallOutcome
  backboardThreadId String?     @map("backboard_thread_id")
  status            CallStatus  @default(pending)
  createdAt         DateTime    @default(now()) @map("created_at")

  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  transcript   Transcript      @relation(fields: [transcriptId], references: [id], onDelete: Cascade)
  signals      CallSignal[]
  aggregates   CallAggregate[]
  tags         CallTag[]
  notes        CallNote[]

  @@index([userId])
  @@index([transcriptId])
  @@index([outcome, status])
  @@map("calls")
}

model CallSignal {
  id          String   @id @default(uuid())
  callId      String   @map("call_id")
  chunkIndex  Int      @map("chunk_index")
  signalType  String   @map("signal_type")
  signalData  Json     @map("signal_data")
  confidence  Float
  startTime   Float    @map("start_time")
  endTime     Float    @map("end_time")

  call Call @relation(fields: [callId], references: [id], onDelete: Cascade)

  @@index([callId])
  @@map("call_signals")
}

model CallAggregate {
  id         String   @id @default(uuid())
  callId     String   @map("call_id")
  features   Json
  computedAt DateTime @default(now()) @map("computed_at")

  call Call @relation(fields: [callId], references: [id], onDelete: Cascade)

  @@index([callId])
  @@map("call_aggregates")
}

model Playbook {
  id                   String   @id @default(uuid())
  userId               String   @map("user_id")
  title                String
  content              String   @db.Text
  callCount            Int      @map("call_count")
  confidenceScores     Json?    @map("confidence_scores")
  backboardDocumentId  String?   @map("backboard_document_id")
  createdAt            DateTime @default(now()) @map("created_at")

  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("playbooks")
}

model CallTag {
  id        String   @id @default(uuid())
  callId    String   @map("call_id")
  name      String
  color     String?
  createdAt DateTime @default(now()) @map("created_at")

  call Call @relation(fields: [callId], references: [id], onDelete: Cascade)

  @@index([callId])
  @@index([name])
  @@map("call_tags")
}

model CallNote {
  id        String   @id @default(uuid())
  callId    String   @map("call_id")
  content   String   @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  call Call @relation(fields: [callId], references: [id], onDelete: Cascade)

  @@index([callId])
  @@map("call_notes")
}

// ---------------------------------------------------------------------------
// Auth.js / NextAuth (Prisma Adapter)
// ---------------------------------------------------------------------------

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String  @unique @map("session_token")
  userId       String  @map("user_id")
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  image         String?

  transcripts Transcript[]
  calls       Call[]
  playbooks   Playbook[]
  accounts Account[]
  sessions Session[]

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
  @@map("verification_tokens")
}
